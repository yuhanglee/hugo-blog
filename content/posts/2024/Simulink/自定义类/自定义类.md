在2008a版本中推出

- 仅空白行和注释可以位于 `classdef` 的前面。
    
- 类定义文件可以位于 MATLAB® 路径上的文件夹中，也可以位于父文件夹在 MATLAB 路径上的类文件夹中。类文件夹名称以 `@` 字符开始，后跟类名称（例如 `@MyClass`）。    
- `properties`]、`methods`、`events`和 `enumeration`也是 MATLAB 函数的名称，这些函数用于查询给定对象或类名称的各个类成员。
- 属性、事件和枚举成员不能与其定义类同名。
- 您可以在主类文件以外的文件中定义方法。

```matlab
classdef Motor < ElectricVehicleComponent
   
    properties
        CurrentSpeed = 0
        SpeedRange = [0, 180]
    end

    methods
        function motor = start(motor,speed)
            arguments
                motor (1,1) Motor
                speed (1,1) {mustBeReal, mustBeNonnegative}
            end
            if motor.CurrentSpeed > 0
                error("Motor:start:MotorAlreadyRunning",...
                    "Cannot start a motor that is already running.")
            end
            motor.CurrentSpeed = speed;   
        end
        
        function motor = stop(motor)
            if motor.CurrentSpeed == 0
                error("Motor:start:MotorNotRunning",...
                    "Cannot stop a motor that is not running.")
            end
            motor.CurrentSpeed = 0;
        end
    end
end
```



## 定义枚举类

通过向类定义中添加 `enumeration` 代码块可创建枚举类。例如，`WeekDays` 类列举一周中的工作日。

```matlab
classdef WeekDays
   enumeration
      Monday, Tuesday, Wednesday, Thursday, Friday
   end
end
```

为了执行以下各节中的 MATLAB® 代码，请将 `WeekDays` 类定义放在您的路径上的 `.m` 文件中。

### 构造枚举成员

使用类名和成员名引用枚举成员：
ClassName.MemberName
例如，将枚举成员 `WeekDays.Tuesday` 赋给变量 `today`：

`today = WeekDays.Tuesday;`

`today` 是 `WeekDays` 类的变量：
```
today = 
    Tuesday
```

### 转换为超类值

如果枚举类指定超类，您可以通过将枚举对象传递给超类构造函数，将枚举对象转换为超类。然而，超类构造函数必须能够接受自己的类作为输入，并返回超类的实例。MATLAB 的内置数值类（如 `uint32`）允许此转换。

例如，`Bearing` 类派生自 `uint32` 内置类：

```matlab
classdef Bearing < uint32
   enumeration
      North (0)
      East  (90)
      South (180)
      West  (270)
   end
end
```

将 `Bearing.East` 成员赋给变量 `a`：
`a = Bearing.East;`
将 `a` 传递给超类构造函数，并返回 `uint32` 值：
`b = uint32(a);`
`uint32` 构造函数接受 `Bearing` 子类的对象，并返回 `uint32` 类的对象。

### 在枚举类中定义方法

在枚举类中定义方法的方式与在任何 MATLAB 类中的定义方式一样。例如，为 `WeekDays` 枚举类定义一个名为 `isMeetingDay` 的方法。用例是用户在星期二定期开会。该方法检查输入参量是否为 `WeekDays` 成员 `Tuesday` 的实例。

```matlab
classdef WeekDays
   enumeration
      Monday, Tuesday, Wednesday, Thursday, Friday
   end
   methods
      function tf = isMeetingDay(obj)
         tf = WeekDays.Tuesday == obj;
      end
   end
end
```

使用 `WeekDays` 类的实例调用 `isMeetingDay`：
```matlab
today = WeekDays.Tuesday;
today.isMeetingDay

ans =
     1


isMeetingDay(WeekDays.Wednesday)
ans =
     0
```

### 在枚举类中定义属性

当必须存储与枚举成员相关的数据时，可向枚举类添加属性。在类构造函数中设置属性值。例如，`SyntaxColors` 类定义三个属性。当引用类成员时，类构造函数将输入参量的值赋给对应的属性。

```matlab
classdef SyntaxColors
   properties
      R
      G
      B
   end
   methods
      function c = SyntaxColors(r, g, b)
         c.R = r; c.G = g; c.B = b;
      end
   end
   enumeration
      Error   (1, 0, 0)
      Comment (0, 1, 0)
      Keyword (0, 0, 1)
      String  (1, 0, 1)
   end
end
```

当引用枚举成员时，构造函数会初始化属性值：

```matlab
e = SyntaxColors.Error;
e.R
ans =
    1
```

### 枚举类构造函数调用顺序

枚举代码块中的每个语句均为枚举成员的名称，其后可跟参量列表。如果枚举类定义了构造函数，MATLAB 会调用该构造函数来创建枚举实例。

MATLAB 为没有显式定义构造函数的所有枚举类提供默认构造函数。默认构造函数创建枚举类的实例时：

- 如果枚举成员没有定义输入参量，则不使用输入参量
- 用枚举类中为该成员定义的输入参量
  
例如，`Bool` 类的输入参量是 `0`（表示 `Bool.No`）和 `1`（表示 `Bool.Yes`）。

```matlab
classdef Bool < logical
   enumeration
      No  (0)
      Yes (1)
   end
end
```

值 `0` 和 `1` 属于 `logical` 类，因为默认构造函数将参量传递给第一个超类。也就是说，以下语句：
`n = Bool.No;`
导致对 `logical` 的调用，等效于构造函数中的以下语句：
```matlab
function obj = Bool(val)
   obj@logical(val)
end
```
MATLAB 只将成员参量传递给第一个超类。例如，假设 `Bool` 派生自另一个类：
```matlab
classdef Bool < logical & MyBool
   enumeration
      No  (0)
      Yes (1)
   end
end
```
`MyBool` 类可以添加一些特化行为：
```matlab
classdef MyBool
   methods
      function boolValues = testBools(obj)
         ...
      end
   end
end
```
默认的 `Bool` 构造函数的行为类似以下函数：
- 参量传递给第一个超类构造函数
- 没有参量传递给后续构造函数

```matlab
function obj = Bool(val)
   obj@logical(val) 
   obj@MyBool       
end
```


## 包含类定义的文件夹

### 类定义位于路径上
要调用类方法，类定义必须位于 MATLAB® 路径上，如下面各节所述。

### 类和路径文件夹
有两种类型的文件夹可以包含类定义文件。
- 路径文件夹 - 文件夹位于 MATLAB 路径上，文件夹名称不以 `@` 字符开头。当您要在一个文件夹中包含多个类和函数时，请使用这种类型的文件夹。一个类的完整定义必须包含在一个文件中。
- 类文件夹 - 文件夹名称以 @ 字符开头，后跟类名。该文件夹不在 MATLAB 路径上，但其父文件夹在该路径上。当您要使用多个文件定义一个类时，请使用此类型的文件夹。


### 使用路径文件夹
包含类定义文件的文件夹位于 MATLAB 路径中。因此，放置在路径文件夹中的类定义在优先级方面的行为和任何普通函数一样 - 在 MATLAB 路径上第一次出现的名称优先于随后出现的所有相同名称。
每个类定义文件的名称必须与用 `classdef` 关键字指定的类的名称相匹配。使用路径文件夹就无需为每个类创建单独的类文件夹。但是，一个类的完整定义，包括所有方法，必须包含在单个文件中。
假设您在单个文件夹中定义了三个类：
```matlab
.../path_folder/MyClass1.m
.../path_folder/MyClass2.m
.../path_folder/MyClass3.m
```

要使用这些类，请将 `path_folder` 添加到您的 MATLAB 路径：
`addpath path_folder`


### 使用类文件夹

类文件夹的名称始终以 `@` 字符开头，后跟类名称。类文件夹必须包含在路径文件夹中，但类文件夹不在 MATLAB 路径上。将类定义文件放在类文件夹中，该文件夹也可以包含单独的方法文件。类定义文件必须与类文件夹同名（除 `@` 字符外）。
```matlab
.../parent_folder/@MyClass/MyClass.m
.../parent_folder/@MyClass/myMethod1.m
.../parent_folder/@MyClass/myMethod2.m
```
每个文件夹只能定义一个类。文件的扩展名均为 `.m` 或 `.p`。独立方法可以是扩展名为 `.mlx` 的实时函数。

当您要使用多个文件定义一个类时，请使用类文件夹。MATLAB 将类文件夹中的任何函数文件视为类的一个方法。函数文件可以是 MATLAB 代码 (`.m`)、实时代码文件格式 (`.mlx`)、MEX 函数（平台相关的扩展名）和 P 代码文件 (`.p`)。

MATLAB 将类文件夹中的任何文件显式标识为该类的方法。这使您能够使用更模块化的方法来编写您的类方法。

每个文件的基本名称必须为有效的 MATLAB 函数名称。有效的函数名称以字母字符开头，并且可以包含字母、数字或下划线。

### 类文件夹内的私有文件夹中的函数
私有文件夹中的函数只能从 `private` 文件夹紧邻的父级文件夹中定义的函数访问。在类文件夹中的 `private` 文件夹中定义的任何函数只能从类的方法中调用。函数可以访问类的私有成员，但它们本身不是方法。它们不要求将对象作为输入传递，且只能使用函数表示法来调用。当您需要可通过类的多个方法调用的辅助函数时，请使用 `private` 文件夹中的函数。
如果类文件夹包含 `private` 文件夹，则只有类文件夹中定义的类才能访问 `private` 文件夹中定义的函数。子类无法访问超类私有函数。
如果您需要子类能够访问超类的私有函数，请将这些函数定义为超类的受保护方法。指定这些方法时，将 `Access` 属性设置为 `protected`。

#### 调度私有文件夹中的方法
如果类在类文件夹的 `private` 文件夹中定义了函数，则 MATLAB 在决定调度私有函数还是 `classdef` 文件的方法时，将遵循以下优先级规则：
- 使用圆点表示法 (`obj.methodName`) 时，`classdef` 文件中定义的方法优先于 `private` 文件夹中的函数。
- 使用函数表示法 (`methodName(obj)`) 时，`private` 文件夹中的函数优先于 `classdef` 文件中定义的方法。

#### 私有文件夹中不应出现类定义
您不能将类定义（`classdef` 文件）放入私有文件夹中，因为这样做不符合类或路径文件夹的要求。

### 类优先级和 MATLAB 路径
存在多个同名的类定义时，MATLAB 路径上的文件位置决定优先级。文件夹中位于 MATLAB 路径前面的类定义优先于该路径中后面的任何类。
如果函数位于路径中较早出现的文件夹中，则与路径文件夹中的类同名的函数优先于该类。但是，在类文件夹（@ 文件夹）中定义的类优先于同名的函数，即使该函数是在路径中较早出现的文件夹中定义的也是如此。
例如，此路径包含同名的函数和类。尽管 `fldr1` 中的函数 `Foo` 位于路径的前面，但 `fldr2` 中的类 `Foo` 优先，因为它是在类文件夹中定义的。

| 在路径上的顺序 | 文件夹和文件       | 文件定义的内容 |
| -------------- | ------------------ | -------------- |
| 1              | `fldr1/Foo.m`      | 函数 `Foo`     |
| 2              | `fldr2/@Foo/Foo.m` | 类 `Foo`       |

#### 在以后的版本中，@ 文件夹中的类将不再优先于同名函数
在以后的版本中，类文件夹（@文件夹）中定义的类将不再优先于同名函数，而不管它在路径上的位置如何。从 R2024a 开始，MATLAB 在满足以下三个条件时会发出警告：
- 您在路径中的类文件夹中定义了同名的函数和类。
- 函数在路径中的顺序高于类。
- 您使用函数和类的名称。
    

要确保类在规则更改后仍具有优先级并避免警告，请使用以下选项之一：
- 更新路径配置，将类置于路径中比函数更高的位置。有关使用路径的详细信息，请参阅[什么是 MATLAB 搜索路径？](https://ww2.mathworks.cn/help/matlab/matlab_env/what-is-the-matlab-search-path.html)。
- 从路径中删除函数。
- 重命名函数。

要永久赋予函数优先级并避免警告，请使用以下选项之一：
- 从路径中删除类。
- 重命名类。

### 更改路径以更新类定义
MATLAB 只能将类的一个定义识别为当前定义。如果不存在旧定义的实例（即不再位于路径中靠前位置的定义），MATLAB 会立即将新文件夹识别为当前定义。但是，如果在更改路径之前已有该类的实例，则 MATLAB 是否使用新文件夹中的定义取决于新类的定义方式：
- 如果新定义是在类文件夹（@ 文件夹）中定义的，则 MATLAB 会立即将新文件夹识别为当前类定义。
- 如果新定义是在路径文件夹（非 @ 文件夹）中定义的，则必须在 MATLAB 将新文件夹识别为当前类定义之前清除该类。

#### 类文件夹中的类定义
假设您在两个类文件夹 `fldA` 和 `fldB` 中定义名为 `Foo` 的类的两个版本。
```matlab
fldA/@Foo/Foo.m
fldB/@Foo/Foo.m
```

将文件夹 `fldA` 添加到路径的顶端。
`addpath fldA`
创建类 `Foo` 的实例。MATLAB 使用 `fldA/@Foo/Foo.m` 作为类定义。
`a = Foo;`
将当前文件夹更改为 `fldB`。
`cd fldB`
当前文件夹始终是路径上的第一个文件夹。因此，MATLAB 将 `fldB/@Foo/Foo.m` 视为 `Foo` 类的定义。
`b = Foo;`
MATLAB 自动更新现有实例 `a`，以使用 `fldB` 中新的类定义。

#### 路径文件夹中的类定义
假设您在两个文件夹 `fldA` 和 `fldB` 中定义名为 `Foo` 的类的两个版本，但不使用类文件夹。
`fldA/Foo.m`
`fldB/Foo.m`
将文件夹 `fldA` 添加到路径的顶端。
`addpath fldA`
创建类 `Foo` 的实例。MATLAB 使用 `fldA/Foo.m` 作为类定义。
`a = Foo;`
将当前文件夹更改为 `fldB`。
`cd fldB`
当前文件夹实际上位于路径的顶端。但是，MATLAB 没有将 `fldB/Foo.m` 识别为 `Foo` 类的定义。MATLAB 继续使用原始的类定义，直到您清除该类。
要使用 `foldB` 中 `Foo` 的定义，请清除 `Foo`。
`clear Foo`
MATLAB 自动更新现有对象，以符合 `fldB` 中的类定义。通常，清除实例变量是不必要的。



## 属性 get 和 set 方法

您可以定义属性 get 和 set 方法，每当访问关联的属性时，MATLAB® 都会自动调用这些方法。要将 get 或 set 方法与给定的属性相关联，请分别使用 `` get.`PropertyName` `` 和 `` set.`PropertyName` `` 形式来命名 get 和 set 方法。
除了访问属性之外，get 和 set 方法还可以执行额外的步骤操作。使用 get 方法可以：
- 计算从属属性的值。
- 以不同于呈现给用户的格式存储数据。

使用 set 方法可以：
- 设计比内置验证方法支持的更复杂的属性验证。
- 发出自定义错误消息。
- 执行作为属性值更改直接结果的操作，如建立或更新与硬件设备的连接或打开文件，从而确保对资源的访问。

get 和 set 方法确实会增加类的开销。在频繁访问的属性的 get 和 set 方法中，请避免复杂和计算量大的运算。

### 属性 get 方法

您可以定义一个 get 方法，以便每当查询关联的属性值时，MATLAB 都会自动调用该方法。该 get 方法必须返回属性值。get 方法使用如下语法，其中 `PropertyName` 是属性的名称。

methods 
   function value = get.PropertyName(obj)
      ...
   end
end

定义 get 或 set 方法的方法块无法指定属性。

例如，`triangleArea` 类为 `Area` 属性定义 get 方法。`Area` 定义为从属属性，这意味着它不存储值。`Area` 的 get 方法按需计算值。

```matlab
classdef triangleArea
   properties
      Base = 1
      Height = 1
   end
   properties (Dependent)
      Area
   end
   methods
      function a = get.Area(obj)
         disp("Executing get.Area method.")
         a = 0.5*obj.Base*obj.Height;
      end
   end
end
```

创建一个 `triangleArea` 的实例。
```matlab
a = triangleArea
a = 
  Executing get.Area method.
  triangleArea with properties:

      Base: 1
    Height: 1
      Area: 0.5000
```
当显示对象时，MATLAB 为其显示的属性调用任何已定义的 get 方法。在本例中，它调用 `get.Area`，并根据 `Base` 和 `Height` 的默认值计算 `Area` 的值。如果 get 方法出错，MATLAB 会隐藏错误并从显示中省略该属性。

更改 `Base` 和 `Height` 的值，并再次访问 `Area`。
```matlab
a.Base = 3;
a.Height = 4;
a.Area
ans =
    6
```

#### get 方法用法
- get 方法不以递归方式调用。
- 当复制值对象（即不从 [`handle`](https://ww2.mathworks.cn/help/matlab/ref/handle-class.html) 类派生）时，在将属性值从一个对象复制到另一个对象时，不调用 get 方法。

### 属性 set 方法
您可以定义一个 set 方法，以便每当关联的属性赋值时，MATLAB 都会自动调用该方法。根据类是值类还是句柄类，set 方法使用以下语法：
- 值类 set 方法必须返回修改后的对象。
```matlab
methods 
       function obj = set.PropertyName(obj,value) 
          ...
       end
    end
```

- 句柄类 set 方法不需要返回修改后的对象。
```matlab
    methods 
       function set.PropertyName(obj,value) 
          ...
       end
    end
```
    

定义 get 或 set 方法的方法块无法指定属性。

例如，`symPosDef` 使用一个 set 方法进行属性验证。当 `inputMatrix` 属性设置为新值时，set 方法调用 [`chol`](https://ww2.mathworks.cn/help/matlab/ref/chol.html) 函数以确定输入矩阵是否为对称正定矩阵。如果是，该方法将 `inputMatrix` 设置为该值。如果不是，该方法将返回一条自定义错误消息。
```matlab
classdef symPosDef
  properties
     inputMatrix = [1 0; 0 1]
  end
  methods
    function obj = set.inputMatrix(obj,val)
      try chol(val)
         obj.inputMatrix = val;
      catch ME
         error("inputMatrix must be symmetric positive definite.")
       end
     end
  end
end
```


#### set 方法用法
- set 方法不以递归方式调用。
- MATLAB 在对象初始化期间向属性赋予默认值时，不调用 set 方法。但是，在构造函数中设置属性值会调用 set 方法。
- MATLAB 在加载对象时调用 set 方法。
- 当 MATLAB 复制值对象（任何非 [`handle`](https://ww2.mathworks.cn/help/matlab/ref/handle-class.html) 对象）时，在将属性值从一个对象复制到另一个对象时，不会调用 set 方法。
- 如果定义属性时其 `AbortSet` 特性等于 `true`，则在所赋的值与当前值相同时，不会调用该属性的 set 方法。但是，如果该属性具有 get 方法，会调用 get 方法以便可以比较这些值。


